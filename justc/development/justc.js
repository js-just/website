/*

MIT License

Copyright (c) 2025 JustStudio. <https://juststudio.is-a.dev/>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

/*

Just an Ultimate Site Tool Configuration language v0.1.0 (development)

*/

(()=>{"use strict";alert("1: Script started");const JUSTC={};JUSTC.Checks={funcRegex:/^function\s*\w*\s*\(\)\s*\{\s*\[native code\]\s*\}$/,objRegex:/^\[object\s*\w*\]$/,sysFunc:(...e)=>{for(const r of e){if(typeof r!="function"||!JUSTC.Checks.funcRegex.test(r+""))throw new JUSTC.Error(JUSTC.Errors.environment)}},sysObj:(...e)=>{for(const r of e){if(typeof r!="object"||!JUSTC.Checks.objRegex.test(r+""))throw new JUSTC.Error(JUSTC.Errors.environment)}}};const e=typeof define==="function"&&define.amd;const r=typeof module==="object"&&module.exports;const t=!e&&!r;alert(`2: Environment detected - isAMD: ${e}, isModule: ${r}, isBrowser: ${t}`);if(!t&&typeof require==="function"){try{JUSTC.NodeWASM=require("./justc.node.js")}catch(e){}}try{const n=t?[]["filter"]["constructor"]("return globalThis")()||[]["filter"]["constructor"]("return this")()||globalThis:globalThis||self||(e?{__justc__:__justc__}:this)||{__justc__:__justc__};alert("3: globalThis_ accessed successfully");if(!t)n.window={};const o=Object;const a=JSON;const s=Array;const i=t?document:null;const l=URL;const c=String;const u=Error;const f=console;const d=Map;const p=t?Blob:null;const E=fetch;const h=t?/^((?!chrome|android).)*safari/i.test(n.navigator.userAgent):false;alert(`4: Core objects initialized, isSafari: ${h}`)}catch(e){alert(`ERROR at core objects: ${e}`);throw e}const n=t?[]["filter"]["constructor"]("return globalThis")()||[]["filter"]["constructor"]("return this")()||globalThis:globalThis||self||(e?{__justc__:__justc__}:this)||{__justc__:__justc__};if(!t)n.window={};const o=Object;const a=JSON;const s=Array;const i=t?document:null;const l=URL;const c=String;const u=Error;const f=console;const d=Map;const p=t?Blob:null;const E=fetch;const h=t?/^((?!chrome|android).)*safari/i.test(n.navigator.userAgent):false;alert(`4: Core objects initialized, isSafari: ${h}`);JUSTC.VERSION=null;JUSTC.GetVersion=function(){return JUSTC.VERSION===null?false:JUSTC.VERSION};JUSTC.SetVersion=function(e){if(!JUSTC.GetVersion())JUSTC.VERSION=e};JUSTC.Errors={initWasm:"JUSTC WebAssembly module hasn't been initialized yet.",wrongInputType:"Argument 0 should be a string.",wasmFailed:"Failed to initialize JUSTC WebAssembly module:",wasmInitFailed:"Unable to initialize JUSTC WebAssembly module.",executionError:"JUSTC/core/js.cpp error:",arrayInput:"Array cannot be converted to JUSTC.",objectInput:"Provided input is not valid object.",arg0:"Invalid argument 0. Run \"JUSTC = 'help'\" for help.",lexerError:"JUSTC/core/lexer.cpp error: ",parseError:"JUSTC/core/parser.cpp error: ",jsonInput:"Argument 0 should be an object.",lexerInput:"Provided input is not valid core.lexer output.",boolInput:"Argument 1 should be a boolean.",environment:"Invalid or compromised environment.",outputMode:"Invalid output format.",version:e=>`Cannot parse lexer tokens as the current JUSTC version is ${JUSTC.VERSION}, and the tokens appear to have been generated by the JUSTC lexer version ${e}.`,redefine:"JUSTC cannot be redefined."};alert("5: JUSTC basic setup complete");if(t){try{JUSTC.Checks.sysFunc(o,s,l,c,u,d,p,E);alert("6.1: System functions check passed");JUSTC.Checks.sysObj(a,f);alert("6.2: System objects check passed");JUSTC.Checks.sysObj(n,i);alert("6.3: Global objects check passed");if(!h)JUSTC.Checks.sysFunc(o.entries,o.defineProperty,o.freeze,a.parse,a.stringify,s.isArray,s.from,l.parse,f.log,f.info,f.error,f.warn,f.group,f.groupEnd);alert("6.4: Object methods check passed");JUSTC.Checks.sysFunc(i.createElement);alert("6.5: Document methods check passed");JUSTC.Checks.sysObj(i.head,n.window);alert("6.6: DOM objects check passed");JUSTC.Checks.sysFunc(i.head.appendChild,i.head.removeChild);alert("6.7: DOM methods check passed")}catch(e){alert(`ERROR in browser checks: ${e}`);throw e}}JUSTC.JUSTC=n.__justc__;n.__justc__=undefined;JUSTC.Error=class extends u{};JUSTC.ErrorEnabled=true;JUSTC.CoreLogsEnabled=false;JUSTC.Silent=false;JUSTC.Experiments=false;alert(`7: JUSTC.JUSTC = ${JUSTC.JUSTC}`);if(!t&&!JUSTC.JUSTC&&!JUSTC.WASM&&JUSTC.NodeWASM){JUSTC.JUSTC=JUSTC.NodeWASM;alert("8: Using NodeWASM")}else if(t&&!JUSTC.JUSTC&&!JUSTC.WASM){alert("ERROR: No WASM module found in browser");throw new JUSTC.Error(JUSTC.Errors.environment)}JUSTC.Console=function(e,...r){if(!JUSTC.Silent){f[e](...r)}};JUSTC.ErrorIfEnabled=function(...e){if(JUSTC.ErrorEnabled){throw new JUSTC.Error(...e)}};JUSTC.Core={};JUSTC.CoreScript=function(code,r){alert(`9: CoreScript called for ${r}`);try{const e=JUSTC.WASM.ccall(r,"number",["string"],[code]);const t=JUSTC.WASM.UTF8ToString(e);JUSTC.WASM.ccall("free_string",null,["number"],[e]);return a.parse(t)}catch(e){alert(`ERROR in CoreScript: ${e}`);throw new JUSTC.Error(JUSTC.Errors[r+"Error"],e)}};JUSTC.Core.Lexer=function e(code){alert("10: Lexer called");if(!JUSTC.WASM){alert("ERROR: WASM not initialized in Lexer");throw new JUSTC.Error(JUSTC.Errors.initWasm)}if(!code||typeof code!="string"||code.length<1)throw new JUSTC.Error(JUSTC.Errors.wrongInputType);const r=JUSTC.CoreScript(code,"lexer");if(r.error){throw new JUSTC.Error((r.lexer?JUSTC.Errors.lexerError:JUSTC.Errors.executionError+" ")+r.error)}else{return r||{}}};JUSTC.Core.Parser=function e(code){alert("11: Parser called");if(!JUSTC.WASM){alert("ERROR: WASM not initialized in Parser");throw new JUSTC.Error(JUSTC.Errors.initWasm)}if(!code||typeof code!="object")throw new JUSTC.Error(JUSTC.Errors.lexerInput);const r=JUSTC.CoreScript(JSON.stringify(code),"parser");if(r.error){throw new JUSTC.Error((r.parser?JUSTC.Errors.parseError:JUSTC.Errors.executionError+" ")+r.error)}else{return r.return||{}}};JUSTC.PrivateFunctions={All:{Lexer:{NeedsWASM:true,Name:"core.lexer",Return:JUSTC.Core.Lexer},Parser:{NeedsWASM:true,Name:"core.parser",Return:function e(r){if(typeof r!="object")throw new JUSTC.Error(JUSTC.Errors.jsonInput);if(typeof r.input!="string"||typeof r.tokens!="object"||!s.isArray(r.tokens)||typeof r.version!="string")throw new JUSTC.Error(JUSTC.Errors.lexerInput);if(!JUSTC.GetVersion())JUSTC.Public.version;if(r.version!=JUSTC.VERSION)throw new JUSTC.Error(JUSTC.Errors.version(r.version));for(const t of r.tokens){if(typeof t!="object"||t.type===undefined||t.start===undefined||typeof t.start!="number"||t.value===undefined)throw new JUSTC.Error(JUSTC.Errors.lexerInput)}return JUSTC.Core.Parser(r)}},CoreErrors:{NeedsWASM:false,Name:"errorsEnabled",Return:()=>{return JUSTC.ErrorEnabled}},CoreLogs:{NeedsWASM:false,Name:"logsEnabled",Return:()=>{return JUSTC.CoreLogsEnabled}},Silent:{NeedsWASM:false,Name:"isSilent",Return:()=>{return JUSTC.Silent}},env:{NeedsWASM:false,Name:"detectedEnvironment",Return:()=>{return e?"AMD":r?"Module/CommonJS":t?"Browser":"unknown"+JUSTC.NodeWASM!=undefined?" (Node.js)":""}}},Available:["errorsEnabled","logsEnabled","isSilent","detectedEnvironment"],WhatToName:{"core.lexer":"Lexer","core.parser":"Parser",errorsEnabled:"CoreErrors",logsEnabled:"CoreLogs",isSilent:"Silent",detectedEnvironment:"env"}};alert("12: Private functions defined");JUSTC.Initialize=async function(){alert("13: Initialize called");try{JUSTC.WASM=await JUSTC.JUSTC();alert("14: WASM initialized successfully");if(JUSTC.CoreLogsEnabled){JUSTC.Console("log","JUSTC WebAssembly module initialized.")}JUSTC.JUSTC=null;delete JUSTC.JUSTC}catch(e){alert(`ERROR in Initialize: ${e}`);JUSTC.Console("error",JUSTC.Errors.wasmFailed,e)}};JUSTC.InitWASM=async function e(r=0){alert(`15: InitWASM called, attempt ${r}`);while(!JUSTC.WASM){r++;alert(`15.${r}: Initializing WASM, attempt ${r}`);await JUSTC.Initialize();if(r>10){alert("ERROR: WASM initialization failed after 10 attempts");throw new JUSTC.Error(JUSTC.Errors.wasmInitFailed)}}if(JUSTC.WASM){alert("16: WASM available, updating private functions");for(const[t,n]of o.entries(JUSTC.PrivateFunctions.All)){if(n.NeedsWASM&&!JUSTC.PrivateFunctions.Available.includes(n.Name)){JUSTC.PrivateFunctions.Available.push(n.Name)}}}};JUSTC.DisplayLogs=function(e){if(e.logfile&&e.logfile.file&&e.logfile.file!=""){throw new JUSTC.Error("Logfile cannot be created in browser.")}if(e.logs&&s.isArray(e.logs)){e.logs.forEach(e=>{if(e.type!="ECHO"){JUSTC.Console(e.type=="ERROR"?"error":"log",`[JUSTC] (${e.time})`,e.message)}})}};JUSTC.DefaultOutputMode="json";JUSTC.TryCatchLog=function(e,r){try{return e()}catch(e){f.log(r);throw e}};JUSTC.Parse=function(code,e=false,r=JUSTC.DefaultOutputMode){alert("17: Parse called");try{const t=JUSTC.WASM.ccall("parse","number",["string","boolean","boolean","string"],[code,e,false,r]);const n=JUSTC.WASM.UTF8ToString(t);JUSTC.WASM.ccall("free_string",null,["number"],[t]);const o=JUSTC.TryCatchLog(()=>a.parse(n),n);return o}catch(e){alert(`ERROR in Parse: ${e}`);f.error(JUSTC.Errors.executionError,e);throw e}};JUSTC.AsyncParse=async function(code,s,i=JUSTC.DefaultOutputMode){alert("18: AsyncParse called");return new Promise((n,o)=>{try{setTimeout(()=>{try{const e=JUSTC.WASM.ccall("parse","number",["string","boolean","boolean","string"],[code,s,true,i]);const r=JUSTC.WASM.UTF8ToString(e);JUSTC.WASM.ccall("free_string",null,["number"],e);const t=JUSTC.TryCatchLog(()=>a.parse(r),r);n(t)}catch(e){alert(`ERROR in AsyncParse setTimeout: ${e}`);console.error(JUSTC.Errors.executionError,e);o(new JUSTC.Error(JUSTC.Errors.executionError,e))}},0)}catch(e){o(e)}})};JUSTC.CheckWASM=function(){if(!JUSTC.WASM){alert("ERROR: CheckWASM failed - WASM not initialized");throw new JUSTC.Error(JUSTC.Errors.initWasm)}};JUSTC.CheckInput=function(e){if(!e||typeof e!="string"){JUSTC.ErrorIfEnabled(c(e).length<32?`"${c(e)}" is not valid JUSTC.`:()=>{try{if(!e.name)throw new JUSTC.Error("");return`Provided ["${e.name}"] is not valid JUSTC.`}catch(e){return"Provided code is not valid JUSTC."}});return true}else return false};JUSTC.fromJSON=function(r){if(s.isArray(r)){throw new JUSTC.Error(JUSTC.Errors.arrayInput)}else{let e="";for(const[t,n]of o.entries(a.parse(a.stringify(r)))){e+=(e.length>0?",":"")+`${t}=${typeof n==="string"?`"${n}"`:n===true?"y":n===false?"n":n===null?"":n}`}return e+"."}};JUSTC.OutputModes=["json","xml","yaml"];JUSTC.VFS=t?class b{constructor(){this.files=new d}createFile(e,r,t={}){const{mimeType:n="text/plain",language:o="text",syntaxHighlighting:s=true}=t;this.files.set(e,{content:r,mimeType:n,language:o});if(s){this._registerFileInDevTools(e,r,o)}return e}_registerFileInDevTools(e,r,t){const n=new p([r],{type:"text/plain"});const o=l.createObjectURL(n);const s=i.createElement("script");s.textContent=`//# sourceMappingURL=data:application/json;base64,${btoa(JSON.stringify({version:3,file:e,sources:[e],sourcesContent:[r],mappings:""}))}`;i.head.appendChild(s);i.head.removeChild(s);l.revokeObjectURL(o)}getFile(e){return this.files.get(e)}listFiles(){return s.from(this.files.keys())}}:undefined;JUSTC.CurrentVFS=t&&!h?new JUSTC.VFS:undefined;JUSTC.Check=code=>{if(JUSTC.CheckInput(code))throw new JUSTC.Error(JUSTC.Errors.wrongInputType);JUSTC.CheckWASM()};JUSTC.RunAsync=async(code,e,...r)=>{JUSTC.Check(code);const t=await JUSTC.AsyncParse(code,e,...r);if(t.error){throw new JUSTC.Error(t.error)}else{if(e)JUSTC.DisplayLogs(t);return t.return||{}}};JUSTC.Taskify=(e=false,r=JUSTC.DefaultOutputMode,code)=>{const t=[];for(const n of code){t.push(async()=>{return await JUSTC.RunAsync(n,e,r)})}return t};JUSTC.AsyncOutput=async function(e,r){let t=JUSTC.DefaultOutputMode;let n=0;let o=r.length;const s=r[o-1];if(JUSTC.OutputModes.includes(s)){t=s;o-=1}else if(JUSTC.OutputModes.includes(r[0])){t=r[0];n+=1}return await Promise.all(await Promise.all(JUSTC.Taskify(e,t,r.slice(n,o))))};JUSTC.RegisterImports=function(n){if(t&&!h&&n&&s.isArray(n)&&n.length>0)setTimeout(()=>{try{for(const[e,r,t]of n){JUSTC.CurrentVFS.createFile(e,r,{mimeType:t})}}catch(e){}},0)};JUSTC.Output={parse:t||!JUSTC.Experiments?function(code,e=JUSTC.DefaultOutputMode){alert("19: Output.parse called");JUSTC.Check(code);if(!JUSTC.OutputModes.includes(e))throw new JUSTC.Error(JUSTC.Errors.outputMode);const r=JUSTC.Parse(code,false,e);if(r.error){throw new JUSTC.Error(r.error)}else{JUSTC.RegisterImports(r.imported);return r.return||{}}}:async function(...code){return await JUSTC.AsyncOutput(false,code)},execute:t||!JUSTC.Experiments?function(code,e=JUSTC.DefaultOutputMode){alert("20: Output.execute called");JUSTC.Check(code);if(!JUSTC.OutputModes.includes(e))throw new JUSTC.Error(JUSTC.Errors.outputMode);const r=JUSTC.Parse(code,true,e);if(r.error){throw new JUSTC.Error(r.error)}else{JUSTC.RegisterImports(r.imported);JUSTC.DisplayLogs(r);return r.return||{}}}:async function(...code){return await JUSTC.AsyncOutput(true,code)},initialize:async function(){alert("21: Output.initialize called");await JUSTC.InitWASM()},stringify:function(e){if(typeof e!="object")throw new JUSTC.Error(JUSTC.Errors.objectInput);return JUSTC.fromJSON(e)},parseAsync:t&&JUSTC.Experiments?async function(...code){return await JUSTC.AsyncOutput(false,code)}:undefined,executeAsync:t&&JUSTC.Experiments?async function(...code){return await JUSTC.AsyncOutput(true,code)}:undefined};JUSTC.Public={get[Symbol.toStringTag](){return"JUSTC"},get["version"](){alert("22: Public.version getter called");JUSTC.CheckWASM();const e=JUSTC.WASM.ccall("version","number");const r=JUSTC.WASM.UTF8ToString(e);JUSTC.WASM.ccall("free_string",null,["number"],[e]);if(!JUSTC.GetVersion()){JUSTC.SetVersion(r)}return r}};for(const[g,S]of o.entries(JUSTC.Output)){if(S!=undefined)o.defineProperty(JUSTC.Public,g,{value:S,writable:false,configurable:false,enumerable:true})}JUSTC.Private=function(e){if(!e||typeof e!="string"||e.length<1)throw new JUSTC.Error(JUSTC.Errors.arg0);if(JUSTC.PrivateFunctions.Available.includes(e)){return JUSTC.PrivateFunctions.All[JUSTC.PrivateFunctions.WhatToName[e]].Return}else{throw new JUSTC.Error(`JUSTC.requestPermissions: "${e}" is either not available or does not exist.`)}};JUSTC.HiddenOutput={requestPermissions:function(e){if(Array.isArray(e)){const r=[];for(const t of e){r.push(JUSTC.Private(t))}return r}return JUSTC.Private(e)}};for(const[g,S]of o.entries(JUSTC.HiddenOutput)){o.defineProperty(JUSTC.Public,g,{value:S,writable:false,configurable:false,enumerable:false})}JUSTC.CreateAsyncExports=function(){const t={};for(const[e,r]of o.entries(JUSTC.Output)){t[e]=async function(...e){await JUSTC.InitWASM();return r.constructor.name==="AsyncFunction"?await r(...e):r(...e)}}for(const[e,r]of o.entries(JUSTC.HiddenOutput)){o.defineProperty(t,e,{value:async function(...e){await JUSTC.InitWASM();return r.constructor.name==="AsyncFunction"?await r(...e):r(...e)},writable:false,configurable:false,enumerable:false})}o.defineProperty(t,Symbol.toStringTag,{value:"JUSTC",configurable:false});o.defineProperty(t,"defineWASM",{value:function(e){if(!JUSTC.JUSTC){JUSTC.JUSTC=e}},writable:false,configurable:false,enumerable:false});return t};alert("23: Starting final setup");if(t){alert("24: Browser environment setup");if("JUSTC"in n.window||"$JUSTC"in n.window){alert("ERROR: JUSTC or $JUSTC already in window");throw new JUSTC.Error(JUSTC.Errors.environment)}o.defineProperty(n.window,"JUSTC",{get:function(){alert("25: window.JUSTC getter called");JUSTC.InitWASM();return o.freeze(JUSTC.Public)},set:function(e){alert(`26: window.JUSTC setter called with: ${e}`);if(typeof e==="string"&&e.length>0){const t={version:"Public.version","core.lexer":"PrivateFunctions.All.Lexer.Return","core.parser":"PrivateFunctions.All.Parser.Return","detected.env":"PrivateFunctions.All.env.Return","options.silent":"Silent","core.errors":"ErrorEnabled","core.logs":"CoreLogsEnabled","options.experiments":"Experiments","options.defaultOutputMode":"DefaultOutputMode"};const n={version:"string","options.silent":"boolean","options.core.errors":"boolean","options.core.logs":"boolean","options.experiments":"boolean","options.defaultOutputMode":"string"};const o=["version","core.lexer","core.parser","detected.env"];const s={true:true,yes:true,y:true,1:true,"+":true,"!0":true,false:false,no:false,n:false,0:false,"-":false,"!1":false};const i=e.split(" ");function r(e){f.info(typeof JUSTC[t[e]]==="function"?JUSTC[t[e]]():JUSTC[t[e]])}if(i.length==1&&i[0]in t)r(i[0]);else{switch(i[0]){case"print":if(i.length!=2||!(i[1]in t))JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else r(i[1]);break;case"set":if(i.length!=3||!(i[1]in t)||typeof JUSTC[t[i[1]]]==="function"||(()=>{const e=i[1];const r=n[e];const t=i[2];switch(r){case"boolean":return!(t in s);case"string":return e==="options.defaultOutputMode"&&!JUSTC.OutputModes.includes(t);default:return false}})()||o.includes(i[1]))JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else if(n[i[1]]==="boolean"){JUSTC[t[i[1]]]=s[i[2]]}else{JUSTC[t[i[1]]]=i[2]}break;case"switch":if(i.length!=2||!(i[1]in t||n[i[1]]!="boolean"))JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else{JUSTC[t[i[1]]]=!JUSTC[t[i[1]]]}break;case"enable":case"allow":if(i.length!=2||!(i[1]in t||n[i[1]]!="boolean"))JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else{JUSTC[t[i[1]]]=true}break;case"disable":case"disallow":if(i.length!=2||!(i[1]in t||n[i[1]]!="boolean"))JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else{JUSTC[t[i[1]]]=false}break;case"execute":case"parse":if(i.length<2)JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else{f.log(JUSTC.Output[i[0]](i.slice(1).join(" ")))}break;case"help":f.info("https://just.js.org/justc");break;case"run":if(i.length<3||!["core.lexer","core.parser"].includes(i[1]))JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);else{const a=i[1]==="core.lexer"?JUSTC.PrivateFunctions.All.Lexer.Return:JUSTC.PrivateFunctions.All.Parser.Return;f.log(a(i.slice(2).join(" ")))}break;default:JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine);break}}}else{JUSTC.ErrorIfEnabled(JUSTC.Errors.redefine)}},configurable:false});o.defineProperty(n.window,"$JUSTC",{get:function(){alert("27: window.$JUSTC getter called");return JUSTC.Output.execute},set:function(){alert("ERROR: Trying to set $JUSTC");JUSTC.ErrorIfEnabled("$"+JUSTC.Errors.redefine)},configurable:false});if(!h)setTimeout(async()=>{alert("28: Starting VFS registration");const e=async function(e,r){const t=await(await E(e)).text();r.createFile(e,t,{mimeType:e.endsWith(".cpp")?"text/x-c++src":e.endsWith(".hpp")?"text/x-c++hdr":e.endsWith(".h")?"text/x-chdr":"text/x-csrc"})};try{const r=await(await E(i.currentScript.src.slice(0,-8)+"src/")).json();const t=new JUSTC.VFS;if(!s.isArray(r))return;for(const n of r){if(typeof n!="string")continue;await e(n,t)}alert("29: VFS registration completed")}catch(e){alert(`ERROR in VFS registration: ${e}`)}},0);alert("30: Browser setup completed")}else if(r){alert("31: Module environment");module.exports=JUSTC.CreateAsyncExports()}else if(e){alert("32: AMD environment");define(["require"],function(e){return JUSTC.CreateAsyncExports()})}else{alert("ERROR: Unsupported environment");throw new JUSTC.Error("Unsupported environment.")}alert("33: Script execution completed successfully")})();